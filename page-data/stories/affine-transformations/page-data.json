{"componentChunkName":"component---src-pages-mdx-frontmatter-slug-js","path":"/stories/affine-transformations/","result":{"data":{"mdx":{"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Affine Transformations \",\n  \"subtitle\": \"Pan, Zoom and Skew\",\n  \"summary\": \"Learning about three Affine Transformations.\",\n  \"date\": \"2020-12-17T14:29:05.775Z\",\n  \"tags\": [\"affine transformations\", \"math\", \"3D Graphcis\", \"Computer Graphcis\", \"3D\", \"CGI\", \"mathematics\", \"cool math\"],\n  \"slug\": \"/stories/affine-transformations\",\n  \"featuredImage\": \"../../images/affine-transformations.gif\"\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"In graphics, there is often a need to zoom, pan and skew a set of points. In this article we will take a look at one method to produce such a transformation\\u200A\\u2014\\u200AAffine Transformations\"), mdx(\"p\", null, \"An Affine Transformation is a transformation that preserves the \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://mathworld.wolfram.com/Collinear.html\"\n  }, \"collinearity\"), \" of points and the ratio of their distances. One way to think about these transformation is\\u200A\\u2014\\u200AA transformation is an Affine transformation, if grid lines remain parallel and evenly spaced after the transformation is applied. In fact, that is the definition of the word \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Affine.\"), \" Affine transformations however, do no preserve distances or angles.\"), mdx(\"p\", null, mdx(\"span\", {\n    parentName: \"p\",\n    \"className\": \"gatsby-resp-image-wrapper\",\n    \"style\": {\n      \"position\": \"relative\",\n      \"display\": \"block\",\n      \"marginLeft\": \"auto\",\n      \"marginRight\": \"auto\",\n      \"maxWidth\": \"684px\"\n    }\n  }, \"\\n      \", mdx(\"a\", {\n    parentName: \"span\",\n    \"className\": \"gatsby-resp-image-link\",\n    \"href\": \"/static/67b6d8ad1a8bd38cbe132b17417332f8/2c288/1__5jyImox4B8hL3KYy3VIlJA.png\",\n    \"style\": {\n      \"display\": \"block\"\n    },\n    \"target\": \"_blank\",\n    \"rel\": \"noopener\"\n  }, \"\\n    \", mdx(\"span\", {\n    parentName: \"a\",\n    \"className\": \"gatsby-resp-image-background-image\",\n    \"style\": {\n      \"paddingBottom\": \"36%\",\n      \"position\": \"relative\",\n      \"bottom\": \"0\",\n      \"left\": \"0\",\n      \"backgroundImage\": \"url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAHCAIAAACHqfpvAAAACXBIWXMAAAsTAAALEwEAmpwYAAAA2UlEQVQY042Pu07EMBBF8/+/AaJdIS01W9AuBWQhfrBxTBW0JI7Hk8Fm7YFISIgqnOJKUxzdOxVzoXhOn5mZT6d3a21KKeflXKViLndyfnVszfHi8mq7vdlsrm93O2YupazLH+mcC4OHvn+bpglxnmf6Z/MPMUbnpmEcVwt/ZUTc7+8fHuu2NRCC6axSWr8cTWdXP69yzkQUYxpHN7qFYRi8B+cmAEBEIgqI3ntcEkIIAEBEf2ZrrYWQSuu2bfu+V0oJIbXWjRBSqsPhyRhT17WU8rlpTNd9y19pio9kdLMQUQAAAABJRU5ErkJggg==')\",\n      \"backgroundSize\": \"cover\",\n      \"display\": \"block\"\n    }\n  }), \"\\n  \", mdx(\"img\", {\n    parentName: \"a\",\n    \"className\": \"gatsby-resp-image-image\",\n    \"alt\": \"1  5jyImox4B8hL3KYy3VIlJA\",\n    \"title\": \"1  5jyImox4B8hL3KYy3VIlJA\",\n    \"src\": \"/static/67b6d8ad1a8bd38cbe132b17417332f8/2c288/1__5jyImox4B8hL3KYy3VIlJA.png\",\n    \"srcSet\": [\"/static/67b6d8ad1a8bd38cbe132b17417332f8/5a46d/1__5jyImox4B8hL3KYy3VIlJA.png 300w\", \"/static/67b6d8ad1a8bd38cbe132b17417332f8/0a47e/1__5jyImox4B8hL3KYy3VIlJA.png 600w\", \"/static/67b6d8ad1a8bd38cbe132b17417332f8/2c288/1__5jyImox4B8hL3KYy3VIlJA.png 684w\"],\n    \"sizes\": \"(max-width: 684px) 100vw, 684px\",\n    \"style\": {\n      \"width\": \"100%\",\n      \"height\": \"100%\",\n      \"margin\": \"0\",\n      \"verticalAlign\": \"middle\",\n      \"position\": \"absolute\",\n      \"top\": \"0\",\n      \"left\": \"0\"\n    },\n    \"loading\": \"lazy\",\n    \"decoding\": \"async\"\n  }), \"\\n  \"), \"\\n    \")), mdx(\"p\", null, \"Mathematically, this type of transformation is achieved simply by multiplying the input coordinates by a Transformation Matrix:\"), mdx(\"p\", {\n    \"align\": \"center\"\n  }, \"\\n  \", mdx(\"img\", {\n    parentName: \"p\",\n    \"src\": \"/1c37c6b284e67e429c766173110ba67e/1__QT1T350cR__qQVX28us2ZaQ.gif\"\n  }), \"\\n\"), mdx(\"p\", null, \"In this article we will be focusing on 2D Affine Transformations exclusively, However, we can see that the Transformation Matrix is a 3 dimensional matrix, the reason for this is explained excellently in \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://medium.com/hipster-color-science/computing-2d-affine-transformations-using-only-matrix-multiplication-2ccb31b52181\"\n  }, \"this article\"), \" by \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://medium.com/u/6eb228049ec3\"\n  }, \"Chandler Abraham\"), \".\"), mdx(\"h3\", null, \"Implementing These Transforms\"), mdx(\"p\", null, \"We will be using HTML Canvas along with JavaScript to implement these transformations in code.\"), mdx(\"p\", null, \"First, let\\u2019s define a base upon which we will be experimenting on. Our base will be a grid of lines that will make it easy for us to visualize what each transformation is doing and keep track of where we are.\"), mdx(\"h4\", null, \"Applying Transformation Matrix\"), mdx(\"p\", null, \"The Canvas API offers us a convenient way of applying a transformation matrix to a 2D canvas context\\u200A\\u2014\\u200A\", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/setTransform\"\n  }, \"CanvasRenderingContext2D.setTransform()\")), mdx(\"p\", null, \"This function takes in a matrix in the form:\"), mdx(\"p\", null, mdx(\"span\", {\n    parentName: \"p\",\n    \"className\": \"gatsby-resp-image-wrapper\",\n    \"style\": {\n      \"position\": \"relative\",\n      \"display\": \"block\",\n      \"marginLeft\": \"auto\",\n      \"marginRight\": \"auto\",\n      \"maxWidth\": \"206px\"\n    }\n  }, \"\\n      \", mdx(\"a\", {\n    parentName: \"span\",\n    \"className\": \"gatsby-resp-image-link\",\n    \"href\": \"/static/abca20c7087a99af7051d45975366a3d/95d6f/0__JB7eP1Syj9VeryzO.jpg\",\n    \"style\": {\n      \"display\": \"block\"\n    },\n    \"target\": \"_blank\",\n    \"rel\": \"noopener\"\n  }, \"\\n    \", mdx(\"span\", {\n    parentName: \"a\",\n    \"className\": \"gatsby-resp-image-background-image\",\n    \"style\": {\n      \"paddingBottom\": \"86.89320388349515%\",\n      \"position\": \"relative\",\n      \"bottom\": \"0\",\n      \"left\": \"0\",\n      \"backgroundImage\": \"url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAARABQDASIAAhEBAxEB/8QAGAABAQEBAQAAAAAAAAAAAAAAAAECAwX/xAAUAQEAAAAAAAAAAAAAAAAAAAAA/9oADAMBAAIQAxAAAAHwZrJVGYHUH//EABgQAAIDAAAAAAAAAAAAAAAAAAABECAx/9oACAEBAAEFAhVex//EABQRAQAAAAAAAAAAAAAAAAAAACD/2gAIAQMBAT8BH//EABQRAQAAAAAAAAAAAAAAAAAAACD/2gAIAQIBAT8BH//EABQQAQAAAAAAAAAAAAAAAAAAADD/2gAIAQEABj8CH//EABwQAAICAgMAAAAAAAAAAAAAAAABEBExQXGBof/aAAgBAQABPyHqHgrEbdmSFvk//9oADAMBAAIAAwAAABDDAAD/xAAUEQEAAAAAAAAAAAAAAAAAAAAg/9oACAEDAQE/EB//xAAUEQEAAAAAAAAAAAAAAAAAAAAg/9oACAECAQE/EB//xAAcEAACAwEAAwAAAAAAAAAAAAAAARExQSFxobH/2gAIAQEAAT8QmE7Lul2ob5jE5bheA1E1to32DtCZw9gVn2H/2Q==')\",\n      \"backgroundSize\": \"cover\",\n      \"display\": \"block\"\n    }\n  }), \"\\n  \", mdx(\"img\", {\n    parentName: \"a\",\n    \"className\": \"gatsby-resp-image-image\",\n    \"alt\": \"0  JB7eP1Syj9VeryzO\",\n    \"title\": \"0  JB7eP1Syj9VeryzO\",\n    \"src\": \"/static/abca20c7087a99af7051d45975366a3d/95d6f/0__JB7eP1Syj9VeryzO.jpg\",\n    \"srcSet\": [\"/static/abca20c7087a99af7051d45975366a3d/95d6f/0__JB7eP1Syj9VeryzO.jpg 206w\"],\n    \"sizes\": \"(max-width: 206px) 100vw, 206px\",\n    \"style\": {\n      \"width\": \"100%\",\n      \"height\": \"100%\",\n      \"margin\": \"0\",\n      \"verticalAlign\": \"middle\",\n      \"position\": \"absolute\",\n      \"top\": \"0\",\n      \"left\": \"0\"\n    },\n    \"loading\": \"lazy\",\n    \"decoding\": \"async\"\n  }), \"\\n  \"), \"\\n    \")), mdx(\"p\", null, \"So we can construct our matrix like so:\"), mdx(\"p\", null, \"If we apply this transformation to our context, we would get no change, remember, a scale of 1 represents the default scale. This type of matrix with 1 as the diagonal is called an Identity Matrix. This is the default state of the transformation matrix. \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"setTransform()\"), \" however, resets the current transform and then sets it to our desired matrix all in one function call.\"), mdx(\"h3\", null, \"Zoom\"), mdx(\"p\", null, \"The zoom function is simply a scale transformation. We can derive a scaling factor, and use it to drive the scaling vector in our transformation matrix.\"), mdx(\"p\", null, \"This will scale the grid by 0.5 times is original size. As we can see, even after the scaling is applied, the grid lines remain parallel and evenly spaced. Thus, this is an Affine Transformation.\"), mdx(\"p\", null, \"We can do much more than scaling our canvas by a fixed amount. We can drive the scaling factor with mouse wheel movement to have a zooming in effect, or even animate the zoom using requestAnimationFrame().\"), mdx(\"p\", null, \"But there is a small problem\\u2026The canvas does not scale from the center!\"), mdx(\"h4\", null, \"Offsetting Scale\\xA0Origin\"), mdx(\"p\", null, \"We can offset the origin to be in the center of the canvas (or any other point) like so:\"), mdx(\"p\", null, \"We simply multiply the origin vector (the point you want the origin to be) by the inverse of the scale. This then has the effect of scaling from what ever origin is set.\"), mdx(\"h3\", null, \"Pan\"), mdx(\"p\", null, \"The pan function is just an application of the translation vector (\", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"T\"), \") to our Transformation Matrix.\"), mdx(\"p\", null, \"The translation vector then will just be the sum of the offset and the translation factor. This will ensure that the origin moves along with the translation.\"), mdx(\"p\", null, \"Just like in zoom, the translation factor can be derived from any source.\"), mdx(\"p\", null, \"Here, i am driving the transformation in a circle using some fancy math. This movement can be easily mapped to use mouse position deltas to get a pan on drag effect.\"), mdx(\"h3\", null, \"Skew\"), mdx(\"p\", null, \"The Skew function, as you might have guessed is an application of the Skew vector (\", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Q\"), \") in our Transformation Matrix:\"), mdx(\"p\", null, \"And it too can have any driver.\"), mdx(\"h3\", null, \"Bonus!\"), mdx(\"h4\", null, \"Rotate\"), mdx(\"p\", null, \"It is not immediately obvious how we can use our Transformation Matrix to perform a Rotation, but if we think about it, a rotation is simply a combination of a skew and a scale!\"), mdx(\"p\", {\n    \"align\": \"center\"\n  }, \"\\n  \", mdx(\"img\", {\n    parentName: \"p\",\n    \"src\": \"/c33404e67c7f7bbe07488708880b7b81/1__RfFgGCjiKynbyjoO0uadtg.gif\"\n  }), \"\\n\"), mdx(\"p\", null, \"To active a rotation, we must multiply the scaling factor with cosine of the angle you want to rotate in radians. To then correct the origin, we can subtract the skew from the scale.\"), mdx(\"p\", null, \"As before, the rotation angle can be driven by any kind of driver.\"), mdx(\"h3\", null, \"Finally\\u2026\"), mdx(\"p\", null, \"..we can put everything together to generate the animation from the beginning.\"), mdx(\"p\", null, \"Affine Transformations can also be applied in 3 dimensions! In fact they are pivotal in Rigid Body simulations, but that is a topic for another day.\"), mdx(\"p\", null, \"If you have any questions regarding this or anything I should add, correct or remove, feel free to comment or email me.\"), mdx(\"p\", null, \"Thanks!\"));\n}\n;\nMDXContent.isMDXComponent = true;","frontmatter":{"date":"December 17, 2020","slug":"/stories/affine-transformations","title":"Affine Transformations ","subtitle":"Pan, Zoom and Skew","summary":"Learning about three Affine Transformations.","tags":["affine transformations","math","3D Graphcis","Computer Graphcis","3D","CGI","mathematics","cool math"],"featuredImage":{"childImageSharp":null,"extension":"gif","publicURL":"/static/043543847781bd647fea65dddf77ab90/affine-transformations.gif"}},"fields":{"readingTime":{"text":"4 min read"}}}},"pageContext":{"id":"84b325a6-c91a-58a6-a5a6-49602967a13b","frontmatter__slug":"/stories/affine-transformations","__params":{"frontmatter__slug":"stories"}}},"staticQueryHashes":["2052298874","3890932667"]}